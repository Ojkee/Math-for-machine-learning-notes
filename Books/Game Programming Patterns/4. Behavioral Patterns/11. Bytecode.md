Give behavior the flexibility of data by encoding it as instructions for a virtual machine.

### Problem
Allow designers and modders to extend content without modifying the core engine or rebuilding the project.

### Solution
Design tools such as a UI or template language; these extensions are compiled to bytecode, which is then interpreted by the engine.

#### API for user
![[Pasted image 20250813210032.png]]
![[Pasted image 20250813210042.png]]
![[Pasted image 20250813210057.png]]
![[Pasted image 20250813210407.png]]
```cpp
void set_health(int wizard, int amount);
void set_wisdom(int wizard, int amount);
void set_agility(int wizard, int amount);
```

```cpp
enum struct Inst {
	Set_health      = 0x00,
	Set_wisdom      = 0x01,
	Set_agility     = 0x02,
	Play_sound      = 0x03,
	Spawn_particles = 0x04,
	Literal         = 0x05,
	// And so on
};
```

```cpp
class VM {
public:
	VM()
	: m_stack_size(0) {}
	
	void interpret(char bytecode[], int size) {
		for (int i{}; i < size; ++i) {
			char instruction = bytecode[i];
			switch (instruction) {
			case Inst::Set_health:
				auto amout = pop();
				auto wizard = pop();
				set_health(wizard, amount);
				break;
			case Inst::Set_wisdom:
			case Inst::Set_agility:
				// Same as above
				
			case Inst::Play_sound:
				auto sound = pop()
				play_sound(sound);
				break;
			case Inst::Spawn_particles:
				auto particle = pop();
				spawn_particles(particle);
				break;
			
			case Inst::Literal:
				int value = bytecode[++i];
				push(value);
				break;
				
			case Inst::Get_health:
				auto wizard = pop();
				auto value = get_health(wizard);
				push(value);
				break;
			case Inst::Get_wisdom:
			case Inst::Get_agility:
				// Same as above

			case Inst::Add:
				auto b = pop();
				auto a = pop();
				push(a + b);
				break;
			}
		}
	}

private:
	void push(int value) {
		assert(m_stack_size < MAX_STACK);
		m_stack_[m_stack_size++] = value;
	}

	int pop() {
		assert(m_stack_size > 0);
		return m_stack[--m_stack_size];
	}

	static const int MAX_STACK{128}; 
	int m_stack_size{};
	int m_stack[MAX_STACK];
}
```

### Solution with types (`tagged variant`)
Another variant allows users to use other types.

```cpp
enum struct ValueType {
	Int,
	Double,
	String
};
```
```cpp
struct Value {
	ValueType type;
	union {
		int int_value;
		double double_value;
		char* string_value;
	};
};
```

### Solution with types (`Interface`)
Same as above.

```cpp
class Value {
public:
	virtual Value() {}
	virtual ValueType type() = 0;
	virtual int asInt() {
		// Only on ints
		assert(false);
		return 0;
	}
	// And so on
};
```

```cpp
class IntValue : public Value {
public:
	IntValue(int value)
	: m_value(value) {}

	ValueType type() override { return ValueType::Int; }
	int asInt() { return m_value; }
	
private:
	int m_value{};
};
```
```cpp
// Analogously other types
```
