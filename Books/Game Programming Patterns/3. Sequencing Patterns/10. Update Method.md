Simulate a collection of independent objects by telling each to process one frame
of behavior at a time.

### Problem
Variable pollution and difficulty maintaining many different objects.

```cpp
Entity skeleton{};
bool patrolling_left{true};
double x{0.};

Entity left_statue{};
Entity right_statue{};
int left_statue_frames{};
int right_statue_frames{};

while(run) {
	if (patrolling_left) {
		--x;
		if (x == 0) patrolling_left = false;
	} else {
		++x;
		if (x == 100) patrolling_left = true;
	}
	skeleton.set_x(x);

	if (++left_statue_frames == 90) {
		left_statue_frames = 0;	
		left_statue_frames.shoot_lightning();
	}
	
	if (++right_statue_frames == 80) {
		right_statue_frames = 0;	
		right_statue_frames.shoot_lightning();
	}
	

	// Other functions like 'render(...)'
}
```

### Solution
Encapsulate state in member variables and call update() on every object that needs updating.
![[Pasted image 20250813153342.png]]

```cpp
class Entity {
public:
	Entity()
	: m_x(0),
	  m_y(0) {}

	virtual ~Entity() {}
	virtual void update() = 0;

	double x() { return m_x; }
	double y() { return m_y; }
	void set_x(double x) { m_x = x; }
	void set_y(double y) { m_y = y; }

private:
	double m_x{};
	double m_y{};
};
```

```cpp
class Skeleton : public Entity {
public:
	Skeleton()
	: m_patrolling_left(false) {}

	void update() override {
		if (m_patrolling_left) {
			set_x(x() - 1);
			if (x() == 0) m_patrolling_left = false;
		} else {
			set_x(x() + 1);
			if (x() == 100) m_patrolling_left = true;
		}
	}
	
private:
	bool m_patrolling_left{};
};
```

```cpp
class Statue : public Entity {
	// Analogously to Skeleton class
};
```

```cpp
class World {
public:
	World() 
	: m_num_entities(0),
	  m_run(true) {}

	void game_loop();

private:
	Enitity* m_entities[MAX_ENTITIES];
	int m_num_entities{}; 
	bool m_run{};
};
```
```cpp
void World::game_loop() {
	while (m_run) {
		for (int i{}; i < m_num_entities; ++i) {
			m_entities[i]->update();
		}
	}
}
```
