Cause a series of sequential operations to appear instantaneous or
simultaneous.

### Problem
Simultaneous reads and writes to the same buffer cause conflicts.
![[Pasted image 20250811164642.png]]
```cpp
class Framebuffer {
public:
	Framebuffer() {
		clear();
	}

	void clear() {
		for (int i{}; i < WIDTH * HEIGHT; ++i) {
			m_pixels[i] = WHITE;
		}
	}

	void draw(int x, int y) {
		const auto pos = WIDTH * y + x;
		m_pixels[pos] = BLACK;
	}

	const char* get_pixels() {
		return m_pixels;
	}

private:
	static const int WIDTH{160};
	static const int HEIGHT{120};
	char m_pixels[WIDTH * HEIGHT];
};
```

```cpp
class Scene {
public:
	void draw() {
		m_buffer.draw(1, 1);
		m_buffer.draw(4, 1);
		m_buffer.draw(1, 3);
		m_buffer.draw(2, 4);
		m_buffer.draw(3, 4);
		m_buffer.draw(4, 3);
	}

	Framebuffer& get_buffer() {
		return m_buffer;
	}

private:
	Framebuffer m_buffer{};
};
```
### Solution
Duplicate buffers to separate reads from write.

```cpp
class Scene {
public:
	Scene()
	: m_current(&m_buffers[0]),
	  m_next(&m_buffers[1]) {}
	  
	void draw() {
		// As before
		swap();
	}

	Framebuffer& get_buffer() {
		return *m_current;
	}

private:
	void swap() {
		auto* temp = m_current;
		m_current = m_next;
		next = temp;
	}

	Framebuffer m_buffers[2];
	Framebuffer* m_current;
	Framebuffer* m_next;
};
```


