
### Problem
An entity becomes overwhelmed by handling many states, flags, and branching logic.
![[Pasted image 20250810180248.png]]

### Example with Enums
Handles instance states, but any modification requires changing every method.

```cpp
enum struct State : uint8_t {
	Standing,
	Jumping,
	Ducking,
	Diving
};
```

```cpp
void Heroine::handle_input(Input input) {
	switch (m_state) {
	case State::Standing:
		if (input == PRESS_B) {
			m_state = State::Jumping;
			m_y_velocity = JUMP_VELOCITY;
			set_graphics(IMAGE_JUMP);
		} else if (input == PRESS_DOWN) {
			m_state = State::Ducking;
			m_charge_time = 0;
			set_graphics(IMAGE_DUCK);
		}
		break;
	
	case State::Jumping:
		if (input == PRESS_DOWN) {
			m_state = State::Diving;
			set_graphics(IMAGE_DIVE);
		}
		break;

	case State::Ducking:
		if (input == RELEASE_DOWN) {
			m_state = State::Standing;
			set_graphics(IMAGE_STAND);
		}
		break;
	}
}
```
```cpp
void Heroine::update() {
	if (m_state == State::Ducking) {
		++m_charge_time;
		if (m_charge_time > MAX_CHARGE) {
			super_bomb();
		}
	}
}
```

### Solution
Introduce Finite State Machine (**FSM**).
![[Pasted image 20250810180500.png]]

```cpp
class HeroineState {
public:
	virtual ~Heroine() = default;
	virtual void handle_input(Heroine& heroine, Input input) {}
	virtual void update(Heroine& heroine) {}
};
```

```cpp
class DuckingState : public HeroineState {
public:
	DuckingState()
	: m_charge_time(0) {}

	void handle_input(Heroine& heroine, Input input) override {
		if (input == RELEASE_DOWN) {
			// Change to standing state...
			heroine.set_graphics(IMAGE_STAND);
		}
	}

	void update(Heroine& heroine) override {
		++m_charge_time;
		if (m_charge_time > MAX_CHARGE) {
			heroine.super_bomb();
		}
	}
private:
	int m_charge_time{};
};
```

```cpp
class Heroine {
public:
	virtual void handle_input(Input) {
		m_state->update(*this);
	}
	
	virtual void update() {
		m_state->update(*this);
	}
	
	// Other methods

private:
	HeroineState* m_state;
};
```

### Solution #2
Allow state to return new state.

```cpp
void Heroine::handle_input(Input input) {
	HeroineState* state = m_state->handle_input(*this, input);
	if (state) {
		delete m_state;
		m_state = state;
	}
}
```

```cpp
HeroineState* StandingState::handle_input(Heroine& heroine, Input input) {
	if (input == PRESS_DOWN) {
		// Other code
		return new DuckingState();
	}

	return nullptr;
}
```

### Solution #3
Implementing the enter function. It encapsulates behavior upon change.

```cpp
class StandingState : public HeroineState {
public:
	void enter(Heroine& heroine) override {
		heroine.set_graphics(IMAGE_STAND);
	}
	
	// Other code
};
```

```cpp
void Heroine::handle_input(Input input) {
	HeroineState* state = m_state->handle_input(*this, input);
	if (state) {
		delete m_state;
		m_state = state;
		m_state->enter(*this);
	}
}
```

### Solution #4 
Implement concurrent states by pairing (`m + n`) them instead of duplicating each state (`m x n`) with minor changes.

```cpp
class Heroine {
public:
	// Code

private:
	HeroineState* m_state;
	HeroineState* m_equipment;
};
```

```cpp
void Heroine::handle_input(Input input) {
	m_state->handle_input(*this, input);
	m_equipment->handle_input(*this, input);
}
```

### Solution #5 
Implementing **Hierarchical State Machines**. It reduces code duplication for similar states.

```cpp
class OnGroundState : public HeroineState {
public:
	void handle_input(Heroine& heroine, Input input) override {
		if (input == PRESS_B) {
			// Jump
		} else if (input == PRESS_DOWN) {
			// Duck
		}
	}
};
```

```cpp
class DuckingState : public OnGroundState {
public:
	void handle_input(Heroine& heroine, Input input) override {
		if (input == RELEASE_DOWN) {
			// Stand up
		} else {
			OnGroundState::handle_input(heroine, input);
		}
	}
};
```

### Solution #6
Implementing **Pushdown Automata**. It remembers last state enabling going back to previous state upon change.

![[Pasted image 20250810185720.png]]

