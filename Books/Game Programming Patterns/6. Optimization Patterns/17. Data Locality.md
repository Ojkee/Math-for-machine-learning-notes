Accelerate memory access by arranging data to take advantage of CPU caching.

### Problem 
Scattered data and pointer chasing cause cache misses

![[Pasted image 20250822190637.png]]

```cpp
class GameEntity {
public:
	GameEntity(AIComponent* ai,
			   PhysicsComponent* physics,
			   RenderComponent* render)
	: m_ai(ai),
	  m_physics(physics),
	  m_render(render) {}
	  
	 AIComponent*      ai()      { return m_ai; }
	 PhysicsComponent* physics() { return m_physics; }
	 RenderComponent*  render()  { return m_render; }
	 
private:
	AIComponent* m_ai;
	PhysicsComponent* m_physics;
	RenderComponent* m_render;
};
```

```cpp
class AIComponent {
public:
	void update() { 
		// Implementation
	}
	
private:
	// Goals, mood, etc...
};
```
```cpp
class PhysicsComponent {
public:
	void update() { 
		// Implementation
	}
	
private:
	// Rigid body, velocity, mass, etc...
};
```
```cpp
class RenderComponent {
public:
	void update() { 
		// Implementation
	}
	
private:
	// Mesh, textures, shaders, etc...
};
```

```cpp
while (!game_over) {
	for (auto entity : entities) {
		entity->ai()->update();
	}
	
	for (auto entity : entities) {
		entity->physics()->update();
	}
	
	for (auto entity : entities) {
		entity->render()->update();
	}
}
```

### Solution
Pack data into contiguous memory (e.g. arrays).

![[Pasted image 20250822190949.png]]

```cpp
AIComponent*      ai_components      = new AIComponent[MAX_ENTITIES];
PhysicsComponent* physics_components = new PhysicsComponent[MAX_ENTITIES];
RenderComponent*  render_components  = new RenderComponent[MAX_ENTITIES];
```

```cpp
while (!game_over) {
	for (int i{}; i < num_entities; ++i) {
		ai_component[i].update();
	}
	
	for (int i{}; i < num_entities; ++i) {
		physics_component[i].update();
	}
	
	for (int i{}; i < num_entities; ++i) {
		render_component[i].update();
	}
}
```

### Solution #2 (`managers`)
Closely related classes may use managers. Skipped objects cause cache misses, so keep frequently updated objects at the beginning of the container.

```cpp
class Particle {
public:
	void update() {
		// Implementation
	}
};
```

```cpp
class ParticleSystem {
public:
	ParticleSystem()
	: m_num_particles(0) {}
	
	void update() {
		for (int i{}; i < m_num_active; ++i) {
			m_particles[i].update();
		}
	}
	
	void activate_particle(int idx) {
		assert(idx >= m_num_active);
		
		Particle temp = m_particles[m_num_active];
		m_particles[m_num_active] = m_particles[idx];
		m_particles[idx] = temp;
		
		++m_num_active;
	}
	
	void deactivate_particle(int idx) {
		assert(idx < m_num_active);
		--m_num_active;
		
		Particle temp = m_particles[m_num_active];
		m_particles[m_num_active] = m_particles[idx];
		m_particles[idx] = temp;
	}

private:
	static const int MAX_PARTICLES = 100_000;
	int m_num_particles{};
	int m_num_active{};
	Particle m_particles[MAX_PARTICLES];
};
```

### Solution #3 (`Hot/cold splitting`)
Some fields donâ€™t need space in precious memory if used rarely. Extract them into a separate class and keep as (smaller in size) pointer.

```cpp
class LootDrop {
	friend class AIComponent;
	LootType m_drop;
	int m_min_drops;
	int m_max_drops;
	double m_chance_of_drop;
};
```

```cpp
class AIComponent {
public:
	void update() {
		// Implementation
	}
	
private:
	Animation* m_animation;
	double m_energy;
	Vector m_goal_pos;

	LootDrop* m_loot;
};
```

