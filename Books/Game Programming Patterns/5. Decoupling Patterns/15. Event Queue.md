Decouple when a message or event is sent from when it is processed.

### Problem
- The API blocks the caller until the engine has completely processed the request.
- Requests cannot be processed in aggregate.
- Requests are processed on the wrong thread.

```cpp
class Audio {
public:
	static void play_sound(SoundId id, int volume) {
		ResourdeId resource = load_sound(id);
		int channel = find_open_channel();
		if (channel == -1) return;
		start_sound(resource, channel, volume);
	}
};
```

```cpp
class Menu {
public:
	void on_select(int idx) {
		Audio::play_sound(SOUND_BLOOP, VOL_MAX);
		// Other code
	}
};
```

### Solution 
Use a queue to store events or messages. This Implementation uses ring array as a queue.

```cpp
struct {
	SoundId id;
	int volume;
};
```
```cpp
class Audio {
public:
	static void init() {
		m_head = 0;
		m_tail = 0;
	}
	
	void play_sound(SoundId id, int volume) {
		assert((m_tail + 1) % MAX_PENDING != m_head);
		
		// Prevent stacking same sound
		for (int i = m_head; i != m_tail; i = (i + 1) % MAX_PENDING) {
			if (m_pending[i].id == id) {
				m_pending[i].volume = max(volume, m_pending[i].volume);
				return;
			}
		}
		
		m_pending[m_tail].id = id;
		m_pending[m_tail].volume = volume;
		
		m_tail = (m_tail + 1) % MAX_PENDING;
	}
	
	void update() {
		if (m_head == m_tail) return;
		
		ResourceId resource = load_sound(m_pending[m_head].id);
		int channel = find_open_channel();
		if (channel == -1) return;
		start_sound(resource, channel, m_pending[m_head].volume);
		
		m_head = (m_head + 1) % MAX_PENDING;
	}

private:
	static int m_head{};
	static int m_tail{};
	
	// Array
};
```

![[Pasted image 20250820144556.png]]