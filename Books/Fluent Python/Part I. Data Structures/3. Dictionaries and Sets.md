- Dictionaries are a keystone of Python. Over the years, the familiar `{k1: v1, k2: v2}` literal syntax was enhanced to support unpacking with `**`, pattern matching, as well as `dict` comprehensions.

```python
>>> dial_codes = [
>>> 	(880, 'Bangladesh'),
>>> 	(55, 'Brazil'), 
>>> 	(86, 'China'),
>>> 	(91, 'India'),
>>> 	(62, 'Indonesia'),
>>> 	(81, 'Japan'),
>>> 	(234, 'Nigeria'),
>>> 	(92, 'Pakistan'),
>>> 	(7, 'Russia'),
>>> 	(1, 'United States'),
>>> ]

>>> country_dial = {country: code for code, country in dial_codes}
{'Bangladesh': 880, 'Brazil': 55, 'China': 86, 'India': 91, 'Indonesia': 62, 'Japan': 81, 'Nigeria': 234, 'Pakistan': 92, 'Russia': 7, 'United States': 1}

>>> {code: country.upper() 
>>> 	for country, code in sorted(country_dial.items())
>>> 	if code < 70}
{55: 'BRAZIL', 62: 'INDONESIA', 7: 'RUSSIA', 1: 'UNITED STATES'}
```

```python
>>> def dump(**kwargs):
>>> 	return kwargs

>>> dump(**{'x': 1}, y=2, **{'z': 3})
{'x': 1, 'y': 2, 'z': 3}

>>> {'a': 0, **{'x': 1}, 'y': 2, **{'z': 3, 'x': 4}}
{'a': 0, 'x': 4, 'y': 2, 'z': 3}
```

```python
def get_creators(record: dict) -> list:
	case {'type': 'book', 'api': 2, 'authors': [*names]}:
		return names
	case {'type': 'book', 'api': 1, 'author': name}:
		return [name] 
	case {'type': 'book'}:
		raise ValueError(f"Invalid 'book' record: {record!r}")
	case {'type': 'movie', 'director': name}:
		return [name]
	case _:
		raise ValueError(f'Invalid record: {record!r}')

>>> b1 = dict(api=1, author='Douglas Hofstadter', 
>>> 		type='book', title='Gödel, Escher, Bach')
>>> get_creators(b1)
['Douglas Hofstadter']

>>> from collections import OrderedDict
>>> b2 = OrderedDict(api=2, type='book',
>>> 		title='Python in a Nutshell',
>>> 		authors='Martelli Ravenscroft Hodlen'.split())
>>> get_creators(b2)
['Martelli', 'Ravenscroft', 'Hodlen']

>>> get_creators({'type': 'book', 'pages': 770})
Traceback (most recent call last):
	...
ValueError: Invalid 'book' record: {'type': 'book', 'pages': 770}

>>> get_creators('Spam, spam, spam')
Traceback (most recent call last):
	...
ValueError: Invalid record: 'Spam, spam, spam'
```

```python
>>> food = dict(category='ice cream', flavor='vanilla', cost=199)
>>> match food:
>>> 	case {'category': 'ice cream', **details}:
>>> 		print(f'Ice cream details: {details}')
Ice cream details: {'flavor': 'vanilla', 'cost': 199}
```

--------------------

- Beyond the basic `dict`, the standard library offers handy, ready-to-use specialized mappings like `defaultdict`, `ChainMap`, `OrderedDict`, `Shelf` and `Counter`, all defined in the collections module. With the new dict implementation, `OrderedDict` is not as useful as before, but should remain in the standard library for backward compatibility—and has specific characteristics that dict doesn’t have, such as taking into account key ordering in `==` comparisons. Also in the collections module is the `UserDict`, an easy to use base class to create custom mappings.

```python
>>> from collections import ChainMap
>>> d1 = dict(a=1, b=3)
>>> d2 = dict(a=2, b=4, c=6)
>>> chain = ChainMap(d1, d2)
>>> chain['a']
1
>>> chain['c']
6
>>> chain['c'] = -1
>>> d1
{'a': 1, 'b': 3, 'c': -1}
>>> d2
{'a': 2, 'b': 4, 'c': 6}
```

```python
>>> import collections 
>>> ct = collections.Counter('abracadabra')
>>> ct
Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})

>>> ct.update('aaaaazzz')
>>> ct
Counter({'a': 10, 'z': 3, 'b': 2, 'r': 2, 'c': 1, 'd': 1})

>>> ct.most_common(3)
[('a', 10), ('z': 3), ('b', 2)]
```

```python
import collections

index = collections.defaultdict(list)
index["word"].append("location")
```

```python
import collections

class StrKeyDict(collections.UserDict):
	def __missing__(self, key):
		if isinstance(key, str):
			raise KeyError(key) 
		return self[str(key)]
	
	def __contains__(self, key):
		return str(key) in self.data
	
	def __setitem__(self, key, item):
		self.data[str(key)] = item
```

--------------------

- Two powerful methods available in most mappings are `setdefault` and `update`. The `setdefault` method can update items holding mutable values—for example, in a `dict` of list values—avoiding a second search for the same key. The `update` method allows bulk insertion or overwriting of items from any other mapping, from iterables providing `(key, value)` pairs, and from keyword arguments. `Mapping` constructors also use update internally, allowing instances to be initialized from mappings, iterables, or keyword arguments. Since Python 3.9, we can also use the `|=` operator to update a mapping, and the `|` operator to create a new one from the union of two mappings.

```python
my_dict.setdefault(key, []).append(new_value)
```

```python
>>> d1 = {'a': 1, 'b': 3}
>>> d2 = {'a': 2, 'b': 4, 'c': 6}
>>> d1 | d2
{'a': 2, 'b': 4, 'c': 6}

>>> d1 
{'a': 1, 'b': 3}
>>> d1 |= d2
>>> d1
{'a': 2, 'b': 4, 'c': 6}
```

--------------------

- A clever hook in the mapping API is the `__missing__` method, which lets you customize what happens when a key is not found when using the `d[k]` syntax that invokes `__getitem__`.

```python
class StrKeyDict0(dict):
	def __missing__(self, key):
		if isinstance(key, str):
			raise KeyError(key)
		return self[str(key)]

	def get(self, key, default=None):
		try:
			return self[key]
		except KeyError:
			return default

	def __contains__(self, key):
		return key in self.keys() or str(key) in self.keys()
```

--------------------

- The `collections.abc` module provides the `Mapping` and `MutableMapping` abstract base classes as standard interfaces, useful for runtime type checking. The `MappingProxyType` from the types module creates an immutable facade for a mapping you want to protect from accidental change. There are also `ABC`s for `Set` and `MutableSet`.

```python
>>> my_dict = {}
>>> isinstance(my_dict, abc.Mapping)
True

>>> isinstance(my_dict, abc.MutableMapping)
True
```

```python
>>> from types import MappingProxyType
>>> d = {1: 'A'}
>>> d_proxy = MappingProxyType(d)
>>> d_proxy
mappingproxy({1: 'A'})

>>> d_proxy[1]
'A'

>>> d_proxy[2] = 'x'
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: 'mappingproxy' object does not support item assignment

>>> d[2] = 'B'
>>> d_proxy
mappingproxy({1: 'A', 2: 'B'})
```

--------------------

 - Dictionary views were a great addition in Python 3, eliminating the memory overhead of the Python 2 `.keys()`, `.values()`, and `.items()` methods that built lists duplicating data in the target dict instance. In addition, the `dict_keys` and `dict_items` classes support the most useful operators and methods of `frozenset`.

```python
>>> d = dict(a=10, b=20, c=30)
>>> values = d.values()
>>> values
dict_values([10, 20, 30])

>>> len(values)
3

>>> list(values)
[10, 20, 30]

>>> reversed(values)
<dict_reversevalueiterator object at 0x10e9e7310>

>>> values[0]
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: 'dict_values' object is not subscriptable

>>> d['z'] = 99
>>> d
{'a': 10, 'b', 20, 'c': 30, 'z': 99}
>>> values
dict_values([10, 20, 30, 99])
```

```python
>>> values_class = type({}.values())
>>> v = value_class()
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: cannot create 'dict_values' instances
```

--------------------
