- The main topic of this chapter was the data class builders `collections.namedtuple`, `typing.NamedTuple`, and `dataclasses.dataclass`. We saw that each generates data classes from descriptions provided as arguments to a factory function, or from class statements with type hints in the case of the latter two. In particular, both named tuple variants produce tuple subclasses, adding only the ability to access fields by name, and providing a `_fields` class attribute listing the field names as a tuple of strings.

```python
class Coordinate:
	def __init__(self, lat, lon):
		self.lat = lat
		self.lon = lon
```
```python
>>> from coordinates import Coordinate

>>> moscow = Coordinate(55.76, 37.62)
>>> moscow
<coordinates.Coordinate object at 0x107142f10>

>>> location = Coordinate(55.76, 37.62)
>>> location == moscow
False

>>> (location.lat, location.lon) == (moscow.lat, moscow.lon)
True
```

```python
>>> from collections import namedtuple

>>> Coordinate = namedtuple('Coordinate', 'lat lon')
>>> issubclass(Coordinate, tuple)
True

>>> moscow = Coordinate(55.756, 37.617)
>>> moscow
Coordinate(lat=55.756, lon=37.617)

>>> moscow == Coordinate(lat=55.756, lon=37.617)
True
```

```python
>>> import typing

>>> Coordinate = typing.NamedTuple('Coordinate',
>>> 	[('lat', float), ('lon', float)])

>>> issubclass(Coordinate, tuple)
True

>>> typing.get_type_hints(Coordinate)
{'lat': <class 'float'>, 'lon': <class 'float'>}
```

```python
from typing import NamedTuple

class Coordinate(NamedTuple):
	lat: float
	lon: float
	
	def __str__(self):
		ns = 'N' if self.lat >= 0 else 'S'
		we = 'E' if self.lon >= 0 else 'W'
		return f'{abs(self.lat):.1f}°{ns}, {abs(self.lon):.1f}°{we}'

>>> issubclass(Coordinate, typing.NamedTuple)
False

>>> issubclass(Coordinate, tuple)
True
```

```python
from dataclasses import dataclass

@dataclass(frozen=True)
class Coordinate:
	lat: float
	lon: float
	
	def __str__(self):
		ns = 'N' if self.lat >= 0 else 'S'
		we = 'E' if self.lon >= 0 else 'W'
		return f'{abs(self.lat):.1f}°{ns}, {abs(self.lon):.1f}°{we}'
```

--------------------

- Next we studied the main features of the three class builders side by side, including how to extract instance data as a `dict`, how to get the names and default values of fields, and how to make a new instance from an existing one. 

```python
>>> City._fields
('name', 'country', 'population', 'location')

>>> Coordinate = namedtuple('Coordinate', 'lat lon')
>>> delhi_data = ('Delhi NCR', 'IN', 21.935, Coordinate(28.613889, 77.208889))
>>> delhi = City._make(delhi_data)
>>> delhi._asdict()
{'name': 'Delhi NCR', 'country': 'IN', 'population': 21.935,
'location': Coordinate(lat=28.613889, lon=77.208889)}

>>> import json

>>> json.dumps(delhi._asdict())
'{"name": "Delhi NCR", "country": "IN", "population": 21.935,
"location": [28.613889, 77.208889]}'
```

```python
>>> Coordinate = namedtuple('Coordinate', 'lat lon reference', defaults=['WGS84'])

>>> Coordinate(0, 0)
Coordinate(lat=0, lon=0, reference='WGS84')

>>> Coordinate._field_defaults
{'reference': 'WGS84'}
```

--------------------

- This prompted our first look into type hints, particularly those used to annotate attributes in a class statement, using the notation introduced in Python 3.6 with PEP 526—Syntax for Variable Annotations. Probably the most surprising aspect of type hints in general is the fact that they have no effect at all at runtime. Python remains a dynamic language. External tools, like `Mypy`, are needed to take advantage of typing information to detect errors via static analysis of the source code. After a basic overview of the syntax from PEP 526, we studied the effect of annotations in a plain class and in classes built by `typing.NamedTuple` and `@dataclass`.

```python
from typing import NamedTuple

class Coordinate(NamedTuple):
	lat: float
	lon: float
	reference: str = 'WGS84'
```

```python
>>> Coordinate('Ni!', None)
Coordinate(lat='Ni!', lon=None)
```

```python
class DemoPlainClass:
a: int
b: float = 1.1
c = 'spam'
```

- **a** becomes an entry in __annotations__, but is otherwise discarded: no attribute named a is created in the class.
- **b** is saved as an annotation, and also becomes a class attribute with value 1.1.
- **c** is just a plain old class attribute, not an annotation.

```python
>>> from demo_plain import DemoPlainClass
>>> DemoPlainClass.__annotations__
{'a': <class 'int'>, 'b': <class 'float'>}

>>> DemoPlainClass.a
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
AttributeError: type object 'DemoPlainClass' has no attribute 'a'

>>> DemoPlainClass.b
1.1

>>> DemoPlainClass.c
'spam'
```

```python
import typing

class DemoNTClass(typing.NamedTuple):
	a: int
	b: float = 1.1
	c = 'spam'
```

```python
>>> from demo_nt import DemoNTClass
>>> DemoNTClass.__annotations__
{'a': <class 'int'>, 'b': <class 'float'>}

>>> DemoNTClass.a
<_collections._tuplegetter object at 0x101f0f940>

>>> DemoNTClass.b
<_collections._tuplegetter object at 0x101f0f8b0>

>>> DemoNTClass.c
'spam'

>>> DemoNTClass.__doc__
'DemoNTClass(a, b)'

>>> nt = DemoNTClass(8)
>>> nt.a
8

>>> nt.b
1.1

>>> nt.c
'spam'
```

```python
from dataclasses import dataclass

@dataclass
class DemoDataClass:
	a: int
	b: float = 1.1
	c = 'spam'
```

```python
>>> from demo_dc import DemoDataClass
>>> DemoDataClass.__annotations__
{'a': <class 'int'>, 'b': <class 'float'>}

>>> DemoDataClass.__doc__
'DemoDataClass(a: int, b: float = 1.1)'

>>> DemoDataClass.a
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
AttributeError: type object 'DemoDataClass' has no attribute 'a'

>>> DemoDataClass.b
1.1

>>> DemoDataClass.c
'spam'

>>> dc = DemoDataClass(9)
>>> dc.a
9

>>> dc.b
1.1

>>> dc.c
'spam'

>>> dc.a = 10
>>> dc.b = 'oops'
>>> dc.c = 'whatever'
>>> dc.z = 'secret stash'
```

--------------------

- Next, we covered the most commonly used features provided by `@dataclass` and the `default_factory` option of the `dataclasses.field` function. We also looked into the special pseudotype hints `typing.ClassVar` and `dataclasses.InitVar` that are important in the context of data classes. This main topic concluded with an example based on the Dublin Core Schema, which illustrated how to use `dataclasses.fields` to iterate over the attributes of a Resource instance in a custom `__repr__`.

```python
from dataclasses import dataclass, field

@dataclass
class ClubMember:
	name: str
	guests: list = field(default_factory=list)
	athlete: bool = field(default=False, repr=False)
```

```python
from dataclasses import dataclass
from club import ClubMember

class HackerClubMember(ClubMember):
	all_handles = set()
	handle: str = ''
	
	def __post_init__(self):
		cls = self.__class__
		if self.handle == '':
			self.handle = self.name.split()[0]
		if self.handle in cls.all_handles:
			msg = f'handle {self.handle!r} already exists.'
			raise ValueError(msg)
		cls.all_handles.add(self.handle)
```

```python
@dataclass
class C:
	i: int
	j: int = None
	database: InitVar[DatabaseType] = None
	
	def __post_init__(self, database):
		if self.j is None and database is not None:
			self.j = database.lookup('j')
	
c = C(10, database=my_database)
```

```python
from dataclasses import dataclass, field
from typing import Optional
from enum import Enum, auto
from datetime import date

class ResourceType(Enum):
	BOOK = auto()
	EBOOK = auto()
	VIDEO = auto()
	
@dataclass
class Resource:
	"""Media resource description."""
	identifier: str
	title: str = '<untitled>'
	creators: list[str] = field(default_factory=list)
	date: Optional[date] = None
	type: ResourceType = ResourceType.BOOK
	description: str = ''
	language: str = ''
	subjects: list[str] = field(default_factory=list)
	
	def __repr__(self):
		cls = self.__class__
		cls_name = cls.__name__
		indent = ' ' * 4
		res = [f'{cls_name}(']
		for f in fields(cls):
			value = getattr(self, f.name)
			res.append(f'{indent}{f.name} = {value!r},')
		
		res.append(')')
		return '\n'.join(res)
```

--------------------

- Then, we warned against possible abuse of data classes defeating a basic principle of object-oriented programming: data and the functions that touch it should be together in the same class. Classes with no logic may be a sign of misplaced logic. In the last section, we saw how pattern matching works with subjects that are instances of any class—not just classes built with the class builders presented in this chapter.

--------------------