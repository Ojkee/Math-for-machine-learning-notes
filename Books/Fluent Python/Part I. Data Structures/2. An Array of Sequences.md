- Python sequences are often categorized as mutable or immutable, but it is also useful to consider a different axis: flat sequences and container sequences. The former are more compact, faster, and easier to use, but are limited to storing atomic data such as numbers, characters, and bytes. Container sequences are more flexible, but may surprise you when they hold mutable objects, so you need to be careful to use them correctly with nested data structures.

![[Pasted image 20250910184755.png]]

--------------------

- Unfortunately, Python has no foolproof immutable container sequence type: even “immutable” tuples can have their values changed when they contain mutable items like lists or user-defined objects.

![[Pasted image 20250910190938.png]]

```python
>>> a = (10, 'alpha', [1, 2])
>>> b = (10, 'alpha', [1, 2])
>>> a == b
True
```
```python
>>> b[-1].append(99)
>>> a == b
False
>>> b
(10, 'alpha', [1, 2, 99]
```

```python
>>> t = (1, 2, [30, 40])
>>> t[2] += [50, 60]
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> t
(1, 2, [30, 40, 50, 60])
```

--------------------

- List comprehensions and generator expressions are powerful notations to build and initialize sequences. 

```python
>>> symbols = '$¢£¥€¤'
>>> codes = [ord(symbol) for symbol in symbols]
>>> codes
[36, 162, 163, 165, 8364, 164]
```

```python
>>> x = 'ABC'
>>> codes = [ord(x) for x in x]
>>> x
'ABC'
>>> codes
[65, 66, 67]
```

```python
>>> codes = [last := ord(c) for c in x]
>>> last
67
>>> c
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
NameError: name 'c' is not defined
```

```python
>>> colors = ['black', 'white']
>>> sizes = ['S', 'M', 'L']
>>> tshirts = [(color, size) for color in colors for size in sizes]
>>> tshirts
[('black', 'S'), ('black', 'M'), ('black', 'L'), ('white', 'S'), ('white', 'M'), ('white', 'L')]

>>> for color in colors:
>>> 	for size in sizes:
>>> 		print((color, size))

('black', 'S')
('black', 'M')
('black', 'L')
('white', 'S')
('white', 'M')
('white', 'L')
```

```python
>>> symbols = '$¢£¥€¤'
>>> tuple(ord(symbol) for symbol in symbols)
(36, 162, 163, 165, 8364, 164)
>>> import array
>>> array.array('I', (ord(symbol) for symbol in symbols))
array('I', [36, 162, 163, 165, 8364, 164])
```

```python
>>> colors = ['black', 'white']
>>> sizes = ['S', 'M', 'L']
>>> for tshirt in (f'{c} {s}' for c in colors for s in sizes):
>>> 	print(tshirt)
black S
black M
black L
white S
white M
white L		
```

--------------------

- Tuples in Python play two roles: as records with unnamed fields and as immutable lists. When using a tuple as an immutable list, remember that a tuple value is only guaranteed to be fixed if all the items in it are also immutable. Calling `hash(t)` on a tuple is a quick way to assert that its value is fixed. A `TypeError` will be raised if `t` contains mutable items.

```python
>>> lax_coordinates = (33.9425, -118.408056)
>>> city, year, pop, chg, area = ('Tokyo', 2003, 32_450, 0.66, 8014)
>>> traveler_ids = [('USA', '31195855'), ('BRA', 'CE342567'), ('ESP', 'XDA205856')]

>>> for passport in sorted(traveler_ids):
>>> 	print('%s/%s' % passport)
BRA/CE342567
ESP/XDA205856
USA/31195855

>>> for country, _ in traveler_ids:
>>> 	print(country)
USA
BRA
ES
```

```python
>>> def fixed(o):
>>> 	try:
>>> 		hash(o)
>>> 	except TypeError:
>>> 		return False
>>> 	return True

>>> tf = (10, 'alpha', (1, 2))
>>> tm = (10, 'alpha', [1, 2])
>>> fixed(tf)
True
>>> fixed(tm)
False
```

--------------------

- When a tuple is used as a record, tuple unpacking is the safest, most readable way of extracting the fields of the tuple. Beyond tuples, `*` works with lists and iterables in many contexts, and some of its use cases appeared in Python 3.5 with PEP 448— Additional Unpacking Generalizations. Python 3.10 introduced pattern matching with `match/case`, supporting more powerful unpacking, known as destructuring.

```python
>>> lax_coordinates = (33.9425, -118.408056)
>>> latitude, longitude = lax_coordinates 
>>> latitude
3533.9425
>>> longitude
-118.40805
```

```python
>>> b, a = a, b
```

```python
>>> divmod(20, 8)
(2, 4)

>>> t = (20, 8)
>>> divmod(*t)
(2, 4)

>>> quotient, remainder = divmod(*t)
>>> quotient, remainder
(2, 4)
```

```python
>>> import os
>>> _, filename = os.path.split('/home/luciano/.ssh/id_rsa.pub')
>>> filename
'id_rsa.pub'
```

```python
>>> a, b, *rest = range(5)
>>> a, b, rest
(0, 1, [2, 3, 4])

>>> a, b, *rest = range(3)
>>> a, b, rest
(0, 1, [2])

>>> a, b, *rest = range(2)
>>> a, b, rest
(0, 1, []

>>> a, *body, c, d = range(5)
>>> a, body, c, d
(0, [1, 2], 3, 4)

>>> *head, b, c, d = range(5)
>>> head, b, c, d
([0, 1], 2, 3, 4
```

```python
>>> def fun(a, b, c, d, *rest):
>>> 	return a, b, c, d, rest

>>> fun(*[1, 2], 3, *range(4, 7))
(1, 2, 3, 4, (5, 6)
```

```python
>>> *range(4), 4
(0, 1, 2, 3, 4)

>>> [*range(4), 4]
[0, 1, 2, 3, 4]

>>> {*range(4), 4, *(5, 6, 7)}
{0, 1, 2, 3, 4, 5, 6, 7
```

```python
metro_areas = [
	('Tokyo', 'JP', 36.933, (35.689722, 139.691667)),
	('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),
	('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),
	('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),
	('São Paulo', 'BR', 19.649, (-23.547778, -46.635833)),
]
def main():
	print(f'{"":15} | {"latitude":>9} | {"longitude":>9}')
	for name, _, _, (lat, lon) in metro_areas:
		if lon <= 0:
			print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')

if __name__ == '__main__':
	main()
```
```Bash
                |   latitude |  longitude
Mexico City     |    19.4333 |   -99.1333
New York-Newark |    40.8086 |   -74.0204
São Paulo       |   -23.5478 |   -46.635
```

```python
>>> [record] = query_returning_single_row()
>>> [[field]] = query_returning_single_row_with_single_field()
```

```python
match tuple(phone):
	case ['1', *rest]: # North America and Caribbean
		...
	case ['2', *rest]: # Africa and some territories
		...
	case ['3' | '4', *rest]: # Europe
		...
```

```python
case [str(name), _, _, (float(lat), float(lon))]:

case [str(name), *_, (float(lat), float(lon))]
```

```python
match record:
	case [name, _, _, (lat, lon)] if lon <= 0:
		print(f'{name:15} | {lat:9.4f} | {lon:9.4f}'
```

```python
def evaluate(exp: Expression, env: Environment) -> Any:
	"Evaluate an expression in an environment."
	match exp:
	# ... lines omitted
		case ['quote', x]:
			return x
		case ['if', test, consequence, alternative]:
			if evaluate(test, env):
				return evaluate(consequence, env)
			else:
				return evaluate(alternative, env)
		case ['lambda', [*parms], *body] if body:
			return Procedure(parms, body, env)
		case ['define', Symbol() as name, value_exp]:
			env[name] = evaluate(value_exp, env)
	# ... more lines omitted
		case _:
			raise SyntaxError(lispstr(exp)
```

```python
case ['lambda', [*parms], *body] if body:
	return Procedure(parms, body, env)
```

```python
case ['define', [Symbol() as name, *parms], *body] if body:
	env[name] = Procedure(parms, body, env
```

--------------------

- Multidimensional slicing and ellipsis (`...`) notation, as used in `NumPy`, may also be supported by user-defined sequences. Assigning to slices is a very expressive way of editing mutable sequences.

```python
>>> l = [10, 20, 30, 40, 50, 60]
>>> l[:2] # split at 2
[10, 20]
>>> l[2:]
[30, 40, 50, 60]
```

```python
>>> s = 'bicycle'
>>> s[::3]
'bye'
>>> s[::-1]
'elcycib'
>>> s[::-2]
'eccb
```

```python
>>> invoice = """
... 0.....6.................................40........52...55........
... 1909  Pimoroni PiBrella                     $17.50    3    $52.50
... 1489 6mm Tactile Switch x20                  $4.95    2     $9.90
... 1510 Panavise Jr. - PV-201                  $28.00    1    $28.00
... 1601 PiTFT Mini Kit 320x240                 $34.95    1    $34.95
... """

>>> SKU = slice(0, 6)
>>> DESCRIPTION = slice(6, 40)
>>> UNIT_PRICE = slice(40, 52)
>>> QUANTITY = slice(52, 55)
>>> ITEM_TOTAL = slice(55, None)
>>> line_items = invoice.split('\n')[2:]
>>> for item in line_items:
		print(item[UNIT_PRICE], item[DESCRIPTION])
```
```bash
    $17.50     Pimoroni PiBrella
	 $4.95     6mm Tactile Switch x20
    $28.00     Panavise Jr. - PV-201
	$34.95     PiTFT Mini Kit 320x24
```

```python
>>> l = list(range(10))
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

>>> l[2:5] = [20, 30]
>>> l
[0, 1, 20, 30, 5, 6, 7, 8, 9]

>>> del l[5:7]
>>> l
[0, 1, 20, 30, 5, 8, 9]

>>> l[3::2] = [11, 22]
>>> l
[0, 1, 20, 11, 5, 22, 9]

>>> l[2:5] = 100
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: can only assign an iterable

>>> l[2:5] = [100]
>>> l
[0, 1, 100, 22, 9]
```

--------------------

- Repeated concatenation as in seq `* n` is convenient and, with care, can be used to initialize lists of lists containing immutable items. Augmented assignment with `+=` and `*=` behaves differently for mutable and immutable sequences. In the latter case, these operators necessarily build new sequences. But if the target sequence is mutable, it is usually changed in place—but not always, depending on how the sequence is implemented.

```python
>>> l = [1, 2, 3]
>>> l * 5
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
>>> 5 * 'abcd'
'abcdabcdabcdabcdabcd
```

```python
>>> board = [['_'] * 3 for i in range(3)]
>>> board
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]

>>> board[1][2] = 'X'
>>> board
[['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']

>>> weird_board = [['_'] * 3] * 3
>>> weird_board
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]

>>> weird_board[1][2] = 'O'
>>> weird_board
[['_', '_', 'O'], ['_', '_', 'O'], ['_', '_', 'O']
```

```python
>>> l = [1, 2, 3]
>>> id(l)
4311953800

>>> l *= 2
>>> l
[1, 2, 3, 1, 2, 3]

>>> id(l)
4311953800

>>> t = (1, 2, 3)
>>> id(t)
4312681568

>>> t *= 2
>>> id(t)
4301348296
```

--------------------

- The `sort` method and the sorted built-in function are easy to use and flexible, thanks to the optional `key` argument: a function to calculate the ordering criterion. By the way, `key` can also be used with the `min` and `max` built-in functions.

```python
>>> fruits = ['grape', 'raspberry', 'apple', 'banana']
>>> sorted(fruits)
['apple', 'banana', 'grape', 'raspberry']

>>> fruits
['grape', 'raspberry', 'apple', 'banana']

>>> sorted(fruits, reverse=True)
['raspberry', 'grape', 'banana', 'apple']

>>> sorted(fruits, key=len)
['grape', 'apple', 'banana', 'raspberry']

>>> sorted(fruits, key=len, reverse=True)
['raspberry', 'banana', 'grape', 'apple']

>>> fruits
['grape', 'raspberry', 'apple', 'banana']

>>> fruits.sort()
>>> fruits
['apple', 'banana', 'grape', 'raspberry']
```

--------------------

- Beyond lists and tuples, the Python standard library provides `array.array`. Although `NumPy` and `SciPy` are not part of the standard library, if you do any kind of numerical processing on large sets of data, studying even a small part of these libraries can take you a long way.

```python
>>> from array import array
>>> from random import random

>>> floats = array('d', (random() for i in range(10**7)))
>>> floats[-1]
0.07802343889111107

>>> fp = open('floats.bin', 'wb')
>>> floats.tofile(fp)
>>> fp.close()
>>> floats2 = array('d')
>>> fp = open('floats.bin', 'rb')
>>> floats2.fromfile(fp, 10**7)
>>> fp.close()
>>> floats2[-1]
0.07802343889111107

>>> floats2 == floats
True
```

```python
>>> from array import array

>>> octets = array('B', range(6))
>>> m1 = memoryview(octets)
>>> m1.tolist()
[0, 1, 2, 3, 4, 5]

>>> m2 = m1.cast('B', [2, 3])
>>> m2.tolist()
[[0, 1, 2], [3, 4, 5]]

>>> m3 = m1.cast('B', [3, 2])
>>> m3.tolist()
[[0, 1], [2, 3], [4, 5]]

>>> m2[1,1] = 22
>>> m3[1,1] = 33
>>> octets
array('B', [0, 1, 2, 33, 22, 5])
```

```python
>>> numbers = array.array('h', [-2, -1, 0, 1, 2])
>>> memv = memoryview(numbers)
>>> len(memv)
5

>>> memv[0]
-2

>>> memv_oct = memv.cast('B')
>>> memv_oct.tolist()
[254, 255, 255, 255, 0, 0, 1, 0, 2, 0]

>>> memv_oct[5] = 4
>>> numbers
array('h', [-2, -1, 1024, 1, 2])
```

```python
>>> import numpy as np

>>> a = np.arange(12)
>>> a
array([ 0, 1, 2, 3, 4,

>>> type(a)
<class 'numpy.ndarray'>

>>> a.shape
(12,)

>>> a.shape = 3, 4
>>> a
array([[ 0, 1, 2,   3],
	   [ 4, 5, 6,   7],
       [ 8, 9, 10, 11]])

>>> a[2]
array([ 8, 9, 10, 11])

>>> a[2, 1]
9

>>> a[:, 1]
array([1, 5, 9])

>>> a.transpose()
array([[ 0, 4,  8],
	   [ 1, 5,  9],
	   [ 2, 6, 10],
	   [ 3, 7, 11]]
```

```python
>>> import numpy

>>> floats = numpy.loadtxt('floats-10M-lines.txt')
>>> floats[-3:]
array([ 3016362.69195522, 535281.10514262, 4566560.44373946])

>>> floats *= .5
>>> floats[-3:]
array([ 1508181.34597761, 267640.55257131, 2283280.22186973])

>>> from time import perf_counter as pc

>>> t0 = pc(); floats /= 3; pc() - t0
0.03690556302899495

>>> numpy.save('floats-10M', floats)
>>> floats2 = numpy.load('floats-10M.npy', 'r+')
>>> floats2 *= 6
>>> floats2[-3:]
memmap([ 3016362.69195522, 535281.10514262, 4566560.44373946])
```

```python
>>> from collections import deque
>>> dq = deque(range(10), maxlen=10)
>>> dq
deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)

>>> dq.rotate(3)
>>> dq
deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10)

>>> dq.rotate(-4)
>>> dq
deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], maxlen=10)

>>> dq.appendleft(-1)
>>> dq
deque([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)

>>> dq.extend([11, 22, 33])
>>> dq
deque([3, 4, 5, 6, 7, 8, 9, 11, 22, 33], maxlen=10)

>>> dq.extendleft([10, 20, 30, 40])
>>> dq
deque([40, 30, 20, 10, 3, 4, 5, 6, 7, 8], maxlen=10)
```

--------------------