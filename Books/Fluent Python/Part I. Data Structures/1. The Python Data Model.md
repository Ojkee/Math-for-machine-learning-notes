- By implementing special methods, your objects can behave like the built-in types, enabling the expressive coding style the community considers Pythonic.

```python
import coleections

Card = collections.namedtuple('Card', ['rank', 'suit'])

class FrenchDeck:
	ranks = [str(n) for n in range(2, 11)] + list('JQKA')
	suits = 'spades diamonds clubs hearts'.split()
	
	def __init__(self):
		self._cards = [Card(rank, suit) for suit in self.suits
										for rank in self.ranks]
										
	def __len__(self):
		return len(self.cards)
		
	def __getitem__(self, position):
		return self._cards[position]
```

```python
>>> beer_card = Card('7', 'diamonds')
>>> beer_card
Card(rank='7', suit='diamonds')
```
```python
>>> deck = FrenchDeck()
>>> len(deck)
52
```
```python
>>> deck[0]
Card(rank='2', suit='spades')
>>> deck[-1]
Card(rank='A', suit='hearts')
```
```python
>>> from random import choice
>>> choice(deck)
>>> Card(rank='3', suit='hearts')
```
```python
>>> deck[:3]
[Card(rank='2', suit='spades'), Card(rank='3', suit='spades'),
Card(rank='4', suit='spades')
>>> deck[12::13]
[Card(rank='A', suit='spades'), Card(rank='A', suit='diamonds'),
Card(rank='A', suit='clubs'), Card(rank='A', suit='hearts')
```
```python
>>> for card in reversed(deck): # doctest: +ELLIPSIS
		print(card)
...
Card(rank='A', suit='hearts')
Card(rank='K', suit='hearts')
Card(rank='Q', suit='hearts'
...
```
```python
>>> Card('Q', 'hearts') in deck
True
>>> Card('7', 'beasts') in deck
False 
```

- A basic requirement for a Python object is to provide usable string representations of itself, one used for debugging and logging, another for presentation to end users. That is why the special methods `__repr__` and `__str__` exist in the data model.

- Thanks to operator overloading, Python offers a rich selection of numeric types, from the built-ins to `decimal.Decimal` and `fractions.Fraction`, all supporting infix arithmetic operators.  

```python
import math 
	def __init(self, x=0, y=0):
		self.x = x
		self.y = y
		
	def __repr__(self):
		return f'Vector({self.x!r}, {self.y!r})'
		
	def __abs__(self):
		return math.hypot(self.x, self.y)
		
	def __bool__(self):
		return bool(self.x or self.y)
		
	def __add__(self, other):
		x = self.x + other.x
		y = self.y + other.y
		return Vector(x, y)	
		
	def __mul__(self, scalar):
		return Vector(self.x * scalar, self.y * scalar)
```

```python
>>> v = Vector(3, 4)
>>> abs(v)
5.0
```
```python
>>> v * 3
Vector(9, 12)
```
```python
>>> abs(v * 3)
15.0
```
