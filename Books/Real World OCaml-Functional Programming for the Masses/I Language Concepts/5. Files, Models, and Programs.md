- OCaml code is organized into modules, which correspond to files:
	- A file foo.ml defines a module Foo.
    - foo.mli is an interface file, declaring the public API of the module.

- The module system provides:
    - Namespacing (avoid name clashes).
    - Information hiding (via interfaces).
    - Code reuse and abstraction.

- Use the **open** keyword to bring a module’s contents into scope:
    - Avoid open in large scopes — prefer qualified names for clarity (**List.map**).

- You can alias modules using module **X = Y**, and create sub modules.

- To compile multiple files:
    - Use **ocamlc** or ocamlopt, providing source files in dependency order.
    - Interface files (.mli) must be compiled before implementation files (.ml).

- The OCaml top-level (**utop**) can load modules with **#use** (for .ml) or **#mod_use**.
    - Use **#load** and **#require** to bring in compiled modules and external libraries.

- You can define small programs in a single .ml file and compile them using:
    - ocamlopt unix.cmxa yourfile.ml -o yourprog

- Use the **Unix** module (or libraries like **Core**) to interact with the OS, e.g., file I/O, environment.

- It's idiomatic to keep related code together in modules, and split complex projects into multiple files.

- Module contents are immutable by default, but mutable references can be included when needed.

- Interfaces (.mli) are optional, but recommended for:
	- Encapsulation (hide implementation details).
	- Documentation (serve as specs).
	- Compile-time checking.