- OCaml has strong static typing with type inference — most type annotations are optional.

- Arithmetic operators are type-specific (**+** for int, **+.** for float).

- Underscores can be used in numeric literals for readability (e.g. **1_000_000**).

- The let binding is used for defining values and functions; definitions are immutable by default.

- Functions are curried by default — every function takes one argument and returns another function if more are needed.

- The language emphasizes immutability and pure functions, promoting safer and more predictable code.

- Higher-order functions (functions that take functions as arguments) are fully supported and idiomatic.

- OCaml supports parametric polymorphism — functions can operate on any type (**'a -> 'a -> 'a**).

- The option type is used instead of null to safely represent missing values.

- Pattern matching is a fundamental tool for working with data structures and types (e.g. lists, options).

- Tuples and lists are basic, built-in composite types; lists are singly-linked and immutable.

- Records and variants are powerful tools for defining custom data types (detailed in later chapters).

- Mutation is possible but not default — enabled through **ref**, **array**, or mutable fields in **records**.

- Imperative features (like loops, mutable variables) exist, but functional style is preferred.

- REPL (**utop**) is used for interactive exploration and learning.

- Code is compiled using **ocamlc** (bytecode) or **ocamlopt** (native code).

