- Records are named, labeled product types — similar to structs or objects with named fields.
    - Unlike tuples, record fields are accessed by name, not position.

- Defined using the type keyword:
	- **type person = { name: string; age: int }**

- Field access uses dot notation: **person.age**.

- Record values are immutable by default.
    - To make a field mutable, declare it with the mutable keyword.
    - Use **<-** to modify mutable fields.

- You can partially update records immutably using the with keyword:
	- **{ person with age = 31 }**

- Pattern matching works with records:
	- **let { name; age } = person**

- It's possible to omit types in record field declarations if they can be inferred.

- Label names are global — different record types can't share field names unless they're in separate modules.

- To avoid field name conflicts, use qualified access or modules.

- When creating complex or polymorphic records, you can use type parameters:
	- **type 'a boxed = { value: 'a }**

- Records are well-suited for:
    - Grouping named data.
    - Structuring function inputs/outputs clearly.
    - Intermediate representations in compilers, ASTs, etc.