- Understanding the conditions when a context can be canceled should matter when propagating it: for example, an HTTP handler canceling the context when the response has been sent.

- Avoiding leaks means being mindful that whenever a `goroutine` is started, you should have a plan to stop it eventually.

- To avoid bugs with `goroutines` and loop variables, create local variables or call functions instead of closures.

- Understanding that `select` with multiple channels chooses the case randomly if multiple options are possible prevents making wrong assumptions that can lead to subtle concurrency bugs.

- Send notifications using a `chan struct{}` type.

- Using `nil` channels should be part of your concurrency toolset because it allows you to remove cases from `select` statements, for example.

- Carefully decide on the right channel type to use, given a problem. Only unbuffered channels provide strong synchronization guarantees.

- You should have a good reason to specify a channel size other than one for buffered channels.

- Being aware that string formatting may lead to calling existing functions means watching out for possible deadlocks and other data races.

- Calling `append` isn’t always data-race-free; hence, it shouldn’t be used concurrently on a shared slice.

- Remembering that `slices` and `maps` are pointers can prevent common data races.

- To accurately use `sync.WaitGroup`, call the `Add` method before spinning up `goroutines`.

- You can send repeated notifications to multiple `goroutines` with `sync.Cond`.

- You can synchronize a group of `goroutines` and handle errors and contexts with the `errgroup` package.

- `sync` types shouldn’t be copied.
