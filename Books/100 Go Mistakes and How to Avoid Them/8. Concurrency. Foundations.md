- Understanding the fundamental differences between concurrency and parallelism is a cornerstone of the Go developer’s knowledge. Concurrency is about structure, whereas parallelism is about execution.

- To be a proficient developer, you must acknowledge that concurrency isn’t always faster. Solutions involving parallelization of minimal workloads may not necessarily be faster than a sequential implementation. Benchmarking sequential versus concurrent solutions should be the way to validate assumptions.

- Being aware of `goroutine` interactions can also be helpful when deciding between `channels` and `mutexes`. In general, parallel `goroutines` require synchronization and hence `mutexes`. Conversely, concurrent `goroutines` generally require coordination and orchestration and hence `channels`.

- Being proficient in concurrency also means understanding that data races and race conditions are different concepts. Data races occur when multiple `goroutines` simultaneously access the same memory location and at least one of them is writing. Meanwhile, being data-race-free doesn’t necessarily mean deterministic execution. When a behavior depends on the sequence or the timing of events that can’t be controlled, this is a race condition.

- Understanding the Go memory model and the underlying guarantees in terms of ordering and synchronization is essential to prevent possible data races and/ or race conditions.

- When creating a certain number of `goroutines`, consider the workload type. Creating CPU-bound `goroutines` means bounding this number close to the `GOMAXPROCS` variable (based by default on the number of CPU cores on the host). Creating `I/O`-bound `goroutines` depends on other factors, such as the external system.

- Go `contexts` are also one of the cornerstones of concurrency in Go. A context allows you to carry a deadline, a cancellation signal, and/or a list of keys-values.

