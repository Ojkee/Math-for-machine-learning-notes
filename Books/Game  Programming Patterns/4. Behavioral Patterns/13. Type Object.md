Allow the flexible creation of new “classes” by creating a single class, each instance of which represents a different type of object. Changes for a given group require editing many places or deepening inheritance, raising complexity.

### Problem
Rigid type definitions lead to many similar interfaces or classes with overlapping features.
![[Pasted image 20250815163504.png]]
This arrow means ***Inheritance***.

```cpp
class Monster {
public:
	virtual ~Monster() {}
	virtual const char* get_attack() = 0;

protected:
	Monster(int starting_health)
	: m_health(starting_health) {}

private:
	int m_healt{};
};
```

```cpp
class Dragon : public Monster {
public:
	Dragon()
	: Monster(230) {}

	const char* get_attack() override {
		return "The dragon breathes fire!";
	}
};
```
```cpp
class Troll : public Monster {
public:
	Dragon()
	: Monster(48) {}

	const char* get_attack() override {
		return "The troll clubs you!";
	}
};
```
### Solution
Move shared features into a separate type object referenced by instance.

![[Pasted image 20250815163615.png]]
This arrow means ***Reference***.

```cpp
class Breed {
public:
	Breed(int health, const char* attack)
	: m_health(healh),
	  m_attack(attack) {}

	Monster* new_monster() {
		return new Monster(*this);
	}

	int get_health() { 
		return m_health; 
	}

	const char* get_attack() {
		return m_attack;
	}

private:
	int m_health{}; // Starting health;
	const char* m_attack;
};
```

```cpp
class Monster {
	friend class Breed;
	
public:
	const char* get_attack() {
		return m_breed.get_attack();
	}
	
private:
	Monster(Breed& breed)
	: m_healh(breed.get_health()),
	  m_breed(breed) {}

	int m_heath{}; // Current health
	Breed& m_breed;
};
```

```cpp
Monster* monster = some_breed.new_monster();
```

### Solution (`Single inheritance`)
Maintain many groups while making changes within a group easier.

```cpp
class Breed {
public:
	Breed(Breed* parent, int health, const char* attack) 
	: m_health(health),
	  m_attack(attack) {
		if (!parent) {
			if (health == 0) m_health = parent->get_health();
			if (!attack)     m_attack = parent->get_attack();
		}
	}

	int get_health() {
		return m_health; 
	}
	
	const char* get_attack() {
		return m_attack;
	}

private:
	int health{};
	const char* m_attack;
};
```

```json
{
	"Troll": {
		"health": 25,
		"attack": "The troll hits you!"
	},
	"Troll Archer": {
		"parent": "Troll",
		"health": 0,
		"attack": "The troll archer fires an arrow!"
	},
	"Troll Wizard": {
		"parent": "Troll",
		"health": 0,
		"attack": "The troll wizard casts a spell on you!"
	}
}
```

```cpp
class Monster {
	// As before

	const char* get_attack() {
		if (m_health < LOW_HEALTH) {
			return "The monster flails weakly.";
		}
		return m_breed.get_attack();
	}
}
```