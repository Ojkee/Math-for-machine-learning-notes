Allow a single entity to span multiple domains without coupling the domains to each other.

### Problem
Coupling a lot of mechanics in single instance. Inheritance may lead into 'deadly diamond'.
![[Pasted image 20250818193227.png]]

```cpp
class Bjorn {
public:
	Bjorn()
	: m_velocity(0),
	  m_x(0),
	  m_y(0) {}

	void update(World& world, Graphics& graphics);

private:
	static const int WALK_ACCELERATION{1};

	int m_velocity{};
	int m_x{};
	int m_y{};

	Volume m_volume;
	
	Sprite m_sprite_stand;
	Sprite m_sprite_walk_left;
	Sprite m_sprite_walk_right;
};
```
```cpp
void Bjorn::update(World& world, Graphics& graphics) {
	switch (Controller::get_joystick_direction) {
	case DIR_LEFT:
		m_velocity -= WALK_ACCELERATION;
		break;
	case DIR_RIGHT:
		m_velocity += WALK_ACCELERATION;
		break;
	}

	Sprite* sprite = &m_sprite_stand;
	if (m_velocity < 0) {
		sprite = &m_sprite_walk_left;
	} else if (m_velocity > 0) {
		sprite = &m_sprite_walk_right;
	}

	graphics.draw(*sprite, m_x, m_y);
}
```

### Solution
Decouple mechanics in separated instances.

```cpp
class InputComponent {
public:
	virtual ~InputComponent() {}
	virtual void update(Bjorn& bjorn) = 0;
};
```

```cpp
class PlayerInputComponent : public InputComponent {
public:
	void update(Bjorn& bjorn) override {
		switch (Controller::get_joystick_direction()) {
		case DIR_LEFT:
			bjorn.velocity -= WALK_ACCELERATION;
			break;
		case DIR_RIGHT:
			bjorn.velocity += WALK_ACCELERATION;
			break;
		}
	}

private:
	static const int WALK_ACCELERATION{1};
};
```

```cpp
class DemoInputComponent : public InputComponent {
public:
	void update(Bjorn& bjorn) override {
		// AI control
	}
};
```

```cpp
class PhysicsComponent {
public:
	virtual ~PhysicsComponent() {}
	virtual void update(GameObject& obj, World& world) = 0;
}
```

```cpp
class BjornPhysicsComponent : public PhysicsComponent {
public:
	void update(GameObject& obj, World& world) {
		obj.x += obj.velocity;
		world.resolve_collision(
			m_volume, 
			bjorn.x, 
			bjorn.y, 
			bjorn.velocity
		);
	}

private:
	Volume m_volume;
};
```

```cpp
class GraphicsComponent {
	virtual ~GraphicsComponent() {}
	virtual void update(GameObject& obj, World& world) = 0;
};
```

```cpp
class BjornGraphicsComponent : public GraphicsComponent {
public:
	void update(GameObject& obj, Graphics& graphics) {
		Sprite* sprite = &sprite_stand;
		if (m_velocity < 0) {
			sprite = &m_sprite_walk_left;
		} else if (m_velocity > 0) {
			sprite = &m_sprite_walk_right;
		}

		graphics.draw(*sprite, obj.x, obj.y);
	}

private:
	Sprite m_sprite_stand;
	Sprite m_sprite_walk_left;
	Sprite m_sprite_walk_right;
};
```

```cpp
class GameObject {
public:
	int velocity{};
	int x{};
	int y{};

	GameObject(InputComponent* input,
			   PhysicsComponent* physics,
			   GraphicsComponent* graphics)
	: m_input(input),
	  m_physics(physics),
	  m_graphics(graphics) {}
	
	void update(World& world, Graphics& graphics) {
		m_input->update(*this);
		m_physics->updaste(*this, world);
		m_graphics->update(*this, graphics);
	}

private:
	InputComponent m_input;
	PhysicsComponent m_physics;
	GraphicsComponent m_graphics;
};
```

```cpp
GameObject* create_bjorn() {
	return new GameObject(new PlayerInputComponent(),
						  new BjornPhysicsComponent(),
						  new BjornGraphicsComponent());
}
```
```cpp
Bjorn* bjorn = new Bjorn(new PlayerInputComponent());
Bjorn* bjorn = new Bjorn(new DemoInputComponent());   // AI Controlated
```

### Problem (`Communication between components`)
Some components are closely related. They need somehow to communicate with each other.

### Solution
Direct reference between components.

```cpp
class BjornGraphicsComponent {
public:
	BjornGraphicsComponent(BjornPhysicsComponent* physics)
	: m_physics(physics) {}

	void update(GameObject& obj, Graphics& graphics) {
		Sprite* sprite;
		if (!m_physics->is_on_ground()) {
			sprite = &m_sprite_jump;
		} else {
			// And so on
		}

		graphics.draw(*sprite, obj.x, obj.y);
	}

private:
	BjornPhysicsComponent m_physics;

	Sprite sprite_stand;
	Sprite sprite_walk_left;
	Sprite sprite_walk_right;
	Sprite sprite_jump;
};
```

### Solution #2
Another communication mechanism works via messages, avoiding coupling once again.

```cpp
class Bomponent {
public:
	virtual ~Component() {}
	virtual void receive(int message) = 0;
};
```

```cpp
class CotainerObject {
public:
	void send(int message) {
		for (int i{}; i < MAX_COMPONENTS; ++i) {
			if (m_components[i]) {
				m_components[i]->reveive(message);
			}
		}
	}

private:
	static const int MAX_COMPONENTS{10};
	Component* m_components[MAX_COMPONENTS];
};
```
