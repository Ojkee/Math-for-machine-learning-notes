Efficiently locate objects by storing them in a data structure organized by their positions.

### Problem 
Handling interactions between all objects scales poorly, as checking every pair becomes very costly.

```cpp
void handle_melee(Unit* units[], int num_units) {
	for (int a{}; a < num_units - 1; ++a) {
		for (int b{a + 1}; b < num_units; ++b) {
			if (units[a]->position() == units[b]->position()) {
				handle_attack(units[a], units[b]);
			}
		}
	}
}
```

### Solution
Place objects in a spatial data structure and handle interactions based on their positions.

![[Pasted image 20250823200658.png]]
![[Pasted image 20250823201454.png]]
![[Pasted image 20250823204236.png]]

```cpp
class Unit {
	friend class Grid;
	
public:
	Unit(Grid* grid, double x, double y)
	: m_grid(grid),
	  m_x(x),
	  m_y(y),
	  m_prev(nullptr),
	  m_next(nullptr) {
		m_grid->add(this);
	}
	  
	void move(double x, double y) {
		m_grid->move(this, x, y);
	}
	
private:
	double m_x{};
	double m_y{};
	Grid* grid;
	Unit* m_prev;
	Unit* m_next;
};
```

```cpp
class Grid {
public:
	Grid() {
		for (int x{}; x < NUM_CELLS; ++x) {
			for (int y{}; y < NUM_CELLS; y++) {
				m_cells[x][y] = nullptr;
			}
		}
	}
	
	void add(Unit* unit) {
		int cell_x = static_cast<int>(unit->m_x / Grid::CELL_SIZE);
		int cell_y = static_cast<int>(unit->m_y / Grid::CELL_SIZE);
		
		unit->m_prev = nullptr;
		unit->m_next = m_cells[cell_x][cell_y];
		m_cells[cell_x][cell_y] = unit;
		
		if (unit->m_next) {
			unit->m_next->m_prev = unit;
		}
	}
	
	void handle_melee() {
		for (int x{}; x < NUM_CELLS; ++x) {
			for (int y{}; y < NUM_CELLS; ++y) {
				handle_cell(x, y);
			}
		}
	}
	
	void handle_cell(int x, int y) {
		Unit* unit = m_cells[x][y];
		while (unit) {
			handle_unit(unit, unit->m_next);
			if (x > 0 && y > 0) handle_unit(unit, m_cells[x - 1][y - 1]);
			if (x > 0) handle_unit(unit, m_cells[x - 1][y]);
			if (y > 0) handle_unit(unit, m_cells[x][y - 1]);
			if (x > 0 && y < NUM_CELLS) handle_unit(unit, m_cells[x - 1][y + 1]);
			unit = unit->m_next;
		}
	}
	
	void handle_unit(Unit* unit, Unit* other) {
		while (other) {
			if (distance(unit, other) < ATTACK_DISTANCE) {
				handle_attack(unit, other);
			}
			other = other->m_next;
		}
	}
	
	void move(Unit* unit, double x, double y) {
		int old_x = static_cast<int>(unit->m_x / Grid::CELL_SIZE);
		int old_y = static_cast<int>(unit->m_y / Grid::CELL_SIZE);
	
		int cell_x = static_cast<int>(x / Grid::CELL_SIZE);
		int cell_y = static_cast<int>(y / Grid::CELL_SIZE);
		
		unit->m_x = x;
		unit->m_y = y;
		
		if (old_x == cell_x && old_y == cell_y) return;
		
		if (unit->m_prev) {
			unit->m_prev->m_next = unit->m_next;
		}
		
		if (unit->m_next) {
			unit->m_next->m_prev = unit->m_prev;
		}
		
		if (m_cells[old_x][old_y] == unit) {
			m_cells[old_x][old_y] = unit->m_next;
		}
		
		add(unit);
	}
	
	static const int NUM_CELLS = 10;
	static const int CELL_SIZE = 20;
	
private:
	Unit* m_cells[NUM_CELLS][NUM_CELLS];
};
```
