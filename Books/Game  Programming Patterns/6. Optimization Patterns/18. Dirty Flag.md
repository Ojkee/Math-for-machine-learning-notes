Avoid unnecessary word by deferring it until the result is needed. 

![[Pasted image 20250823191812.png]]

### Problem 
Expensive calculations are repeatedly executed even when nothing has actually changed.

![[Pasted image 20250823191830.png]]

```cpp
class Transform {
public:
	static Transfrom origin();
	
	Transform combine(Transform& other);
};
```

```cpp
class GraphNode {
public:
	GraphNode(Mesh* mesh)
	: m_mesh(mesh),
	  m_local(Transform::origin()) {}

	void render(Transform parent_world)	{
		Transform world = m_local.combine(parent_world);
		
		if (m_mesh) render_mesh(m_mesh, world);
		
		for (int i{}; i < m_num_children; ++i) {
			m_children[i]->render(world);
		}
	}

private:
	Mesh* m_mesh;
	Transform m_local;
	
	GraphNode* m_children[MAX_CHILDREN];
	int m_num_children{};
};
```

```cpp
GraphNode* graph = new GraphNode(nullptr);
```

```cpp
void render_mesh(Mesh* mesh, Transform transform);
```

```cpp
m_graph->render(Transform::origin());
```

### Solution
Cache the result and mark if object has changed, if not, use cache.

![[Pasted image 20250823191850.png]]

```cpp
class GraphNode {
public:
	GraphNode(Mesh* mesh)
	: m_mesh(mesh),
	  m_local(Transform::origin()),
	  m_dirty(true) {}
	  
	void set_transform(Transform local)	{
		m_local = local;
		m_dirty = true;
	}
	
	void render(Transform parent_world, bool dirty) {
		dirty |= m_dirty;
		
		if (dirty) {
			m_world = m_local.combine(parent_world);
			m_dirty = false;
		}
		
		if (m_mesh) render_mesh(m_mesh, m_world);
		
		for (int i{}; i < m_num_children; ++i) {
			m_children[i]->render(m_world, dirty);
		}
	}
	
private:
	Transform m_world;
	bool m_dirty{};	
};
```

