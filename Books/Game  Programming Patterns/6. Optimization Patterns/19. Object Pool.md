Improve performance and memory use by reusing objects from a fixed pool instead of allocating  and freeing them individually.

### Problem 
Constantly allocating and deallocating objects may lead to data fragmentation. 

![[Pasted image 20250823192528.png]]

### Solution
Create a fixes sized pool with fixes sized objects.

```cpp
class Particle {
public:
	Particle()
	: m_frames_left(0) {}
	
	void init(double x, double y, double xv, double yv, int lifetime) {
		m_x = x;
		m_y = y;
		m_xv = xv;
		m_yv = yv;
		m_frames_left = lifetime;
	}
	
	bool animate() {
		if (!in_use()) return false;
		
		--m_frames_left;
		m_x += xv;
		m_y += yv;
		return m_frames_left == 0;	
	}
	
	bool in_use() const {
		return m_frames_left > 0;
	}
	
	Particle* get_next() const {
		return m_state.m_next;
	}
	
	void set_next(Particle* next) {
		m_state.m_next = next;
	}
	
private:
	int m_frames_left{};
	union {
		struct {
			double m_x{};
			double m_y{};
			double m_xv{};
			double m_yv{};
		} m_live;
		Particle* m_next;
	} m_state;
};
```

```cpp
class ParticlePool {
public:
	ParticlePool() {
		m_first_available = &m_particles[0];
		
		for (int i{}; i < POOL_SIZE - 1; ++i) {
			m_particles[i].set_next(&m_particles[i + 1]);
		}
		m_particles[POOL_SIZE - 1].set_next(nullptr);
	}	
	
	void create(double x, double y, double xv, double yv, int lifetime) {
		assert(m_first_available);

		Particle* new_particle = m_first_available;
		m_first_available = new_particle.get_next();
		new_particle->init(x, y, xv, yv, lifetime);
	}
	
	void animate() {
		for (int i{}; i < POOL_SIZE; ++i) {
			if (m_particles[i].animate()) {
				m_particles[i].set_next(m_first_available);
				m_first_available = &m_particles[i];
			}
		}
	}	
	
private:
	static const int POOL_SIZE{100};
	Particle m_particles[POOL_SIZE];
	Particle* m_first_available;
};
```

