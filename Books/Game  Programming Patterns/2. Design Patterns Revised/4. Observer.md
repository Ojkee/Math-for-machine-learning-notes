Separates the source of events from the objects reacting to them.

### Problem
Modules are coupled when one needs data from another, even though they should remain independent. For instance: coupling modules, for instance physics engine should not care about achievements  module, yet some achievements may depend on movement calculated in physics module.

### Solution
Decoupling without knowledge between addressee and recipient.
![[Pasted image 20250809145844.png]]

```cpp
class Observer {
public:
	virtual ~Observer() = default;
	virtual void on_notify(const Entity& entity, Event event) = 0;
};
```

```cpp
class Achievements : public Observer {
public:
	void on_notify(const Entity& entity, Event event) override {
		switch (event) {
		case EVENT_ENTITY_FELL:
			if (entity.is_hero() && m_hero_is_on_bridge) {
				unlock(ACHIEVEMENT_FELL_OFF_BRIDGE);
			}
			break;
		}
	}

private:
	unlock(Achievement achievement) {
		// Unlock implementation
	}

	bool m_hero_is_on_Bridge{};
}
```

```cpp
class Subject {
public:
	void add_observer(Observer* observer) {
		// Add to array
	}

	void remove_observer(Observer* observer) {
		// Remove from array
	}
	
	// Etc

protected:
	void notify(const Entity& entity, Event event) {
		for (auto observer : m_observers) {
			observer->on_notify(entity, event);
		}
	}

private:
	Oserver* m_observers[MAX_OBSERVERS];
	int m_num_observers{};
};
```

```cpp
class Physics : public Subject {
public:
	update_entity(Entity& entity);
}
```
```cpp
void Physics::update_entity(Entity& entity) {
	const bool was_on_surface = entity.is_on_surface();
	entity.accelerate(GRAVITY);
	entity.update();
	if (was_on_surface && !entity.is_on_surface()) {
		notify(entity, EVENT_START_FALL);
	}
}
```
Physics engine doesn't care who receives signal, just emits.

### Other representations
#### Linked list
![[Pasted image 20250809145928.png]]
```cpp
class Subject {
public:
	Subject()
	: m_head(nullptr) {}

private:
	Observer* m_head = nullptr;
};
```

```cpp
class Observer {
	friend class Subject;

public:
	Observer()
	: m_next(nullptr) {}

private:
	Observer* m_next = nullptr;
};
```

```cpp
// Appending at the beginning
void Subject::add_observer(Observer* observer) {
	observer.m_next = m_head;
	m_head = observer;
}

void Subject::remove_observer(Observer* observer) {
	// Remove implementation
}

void Subject::notify(const Entity& entity, Event event) {
	auto observer = m_head;
	while (observer) {
		observer->on_notify(entity, event);
		observer = observer->m_next;
	}
}
```

#### Pool of list nodes
![[Pasted image 20250809150647.png]]
