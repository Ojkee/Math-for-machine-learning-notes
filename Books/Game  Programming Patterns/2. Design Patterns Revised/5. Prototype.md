Enables creating objects by cloning a prototype instance.

### Problem
Parallel class hierarchy.
![[Pasted image 20250809202805.png]]
```cpp
class Spawner {
public:
	virual ~Spawner() = default;
	virual Monster* spawnMonster() = 0;
};
```

```cpp
class GhostSpawner : public Spawner {
public:
	Monster* spawnMonster() override {
		return new Ghost();
	}
};
```
```cpp
class DemonSpawner : public Spawner {
public:
	Monster* spawnMonster() override {
		return new Demon();
	}
};
```
```cpp
// And so on
```

### Solution
Implement `clone()` method in existing classes.

```cpp
class Monster {
public:
	virtual ~Monster() = default;
	virtual Monster* clone() = 0;
};
```

```cpp
class Ghost : public Monster {
public:
	Ghost(int health, int speed)
	: m_health(health),
	  m_speed(speed) {}

	Monster* clone() override {
		return new Ghost(m_healht, m_speed);
	}

private:
	int m_health{};
	int m_speed{};
};
```

```cpp
class Spawner {
public:
	Spawner(Monster* prototype)
	: m_prototype(prototype) {}

	Monster* spawnMonster() {
		return m_prototype->clone();
	}

private:
	Monster* m_prototype;
};
```

```cpp
Monster* ghostPrototype = new Ghost(15, 3);
Spawner* ghostSpawner = new Spawner(ghostPrototype);
```

![[Pasted image 20250809204620.png]]

### Solution #2
Same idea, but using spawn functions.

```cpp
typedef Monster* (*SpawnCallback)();
```
```cpp
class Spawner {
public:
	Spawner(SpawnCallback spawn)
	: m_spawn(spawn) {}

	Monster* spawnMonster() {
		return m_spawn();
	}

private:
	SpawnCallback m_spawn;
};
```

```cpp
Monster* spawnGhost() {
	return new Ghost();
}
```
```cpp
Spawner* ghostSpawner = new Spawner(spawnGhost);
```

### Solution #3
Again same idea (surprise surprise), this time abusing templates.

```cpp
class Spawner {
public:
	virtual ~Spawner() = default;
	virtual Monster* spawnMonster() = 0;
};
```
```cpp
template<class T>
class SpawnerFor : public Spawner {
public:
	Monster* spawnMonster() {
		return new T();
	}
};
```

```cpp
Spawner* ghostSpawer = new SpawnerFor<Ghost>();
```