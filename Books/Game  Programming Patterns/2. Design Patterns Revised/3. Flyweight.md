Extracting and sharing common heavy member variables across repeating objects.

### Problem #1
Lots of repeated heavy member variables.
![[Pasted image 20250809131128.png]]

### Solution 
Extraction same constant members.
![[Pasted image 20250809131251.png]]
```cpp
class TreeModel {
private:
	Mesh m_mesh;
	Texture m_bark;
	Texture m_leaves;
};
```

```cpp
class Tree {
private:
	TreeModel* m_model;

	Vector m_position{};
	double m_height{};
	double m_thickness{};
	Color m_bark_tint{};
	Color m_leaf_tint{};
};
```

### Problem #2
Tedious handling enum members.
![[Screenshot from 2025-08-09 13-28-00.png]]
![[Screenshot from 2025-08-09 13-28-05.png]]
![[Screenshot from 2025-08-09 13-28-09.png]]

### Solution 
Replaces large conditionals with shared flyweight instances defined by parameters.
![[Pasted image 20250809133313.png]]

```cpp
class Terrain {
public:
	Terrain(int movement_cost,
			bool is_water,
			Texture texture)
	: m_movement_cost(movement_cost),
	  m_is_water(is_water),
	  m_texture(texture) {}

	int get_movement_cost() const { return m_movement_cost; }
	bool is_water() const { return m_is_water; }
	const Texture& get_texture() const { return m_texture; }

private:
	int m_movement_cost{};
	bool m_is_water{};
	Texture m_texture;
};
```

```cpp
class World {
public:
	World()
	: m_grass_terrain(1, false, GRASS_TEXTURE),
	  m_hill_terrain(3, false, HILL_TEXTURE),
	  m_river_terrain(2, true, RIVER_TEXTURE) {}

private:
	Terrain* m_tiles[WIDTH][HEIGHT];
	Terrain  m_grass_terrain;
	Terrain  m_hill_terrain;
	Terrain  m_river_terrain;
```

### Example benefits
```cpp
void World::generate() {
	// generation inside world
}
```
```cpp
const Terrain& World::get_tile(int x, int y) {
	return *m_tiles[x][y];
}
```
```cpp
int cost = world.get_tile(2, 3)
				.get_movement_cost();
```